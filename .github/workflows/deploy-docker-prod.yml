name: Deploy Docker Prod

on:
  workflow_dispatch:
    inputs:
      be_version:
        description: 'Î∞∞Ìè¨Ìï† BE Î≤ÑÏ†Ñ (Ïòà: 1.2.3)'
        required: true
      be_slot:
        description: 'BE Ïä¨Î°Ø ÏÑ†ÌÉù (Ïòà: blue, green)'
        required: true
        default: 'green'
      fe_version:
        description: 'Î∞∞Ìè¨Ìï† FE Î≤ÑÏ†Ñ (Ïòà: 1.2.3)'
        required: true
      fe_slot:
        description: 'FE Ïä¨Î°Ø ÏÑ†ÌÉù (Ïòà: blue, green)'
        required: true
        default: 'green'


jobs:
  deploy:
    runs-on: ubuntu-latest
    outputs:
      fe_slot: ${{ steps.vars.outputs.fe_slot }}

    env:
      AWS_DEFAULT_REGION: ap-northeast-2
      REGION: asia-northeast3
      ZONE: asia-northeast3-a
      GH_FE_REPO: 100-hours-a-week/16-Hot6-fe
      # BE_VERSION: "v1.0.1"
      # BE_SLOT: "blue"

    steps:
      - name: Checkout Infra Repo
        uses: actions/checkout@v3

      - name: Authenticate to GCP
        uses: google-github-actions/auth@v2
        with:
          credentials_json: '${{ secrets.GCP_SA_KEY }}'

      - name: Set up gcloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Set variables
        id: vars
        run: |
          BE_VERSION="${{ github.event.inputs.be_version }}"
          BE_SLOT="${{ github.event.inputs.be_slot }}"
          FE_VERSION="${{ github.event.inputs.fe_version }}"
          FE_SLOT="${{ github.event.inputs.fe_slot }}"
          REGION="${{ env.REGION }}"
          ZONE="${{ env.ZONE }}"

          # Ìè¨Ìä∏ Îß§Ìïë: blue ‚Üí 8080, green ‚Üí 8081
          if [ "$BE_SLOT" = "blue" ]; then
            BE_PORT=8080
          else
            BE_PORT=8081
          fi
      
          MIG_NAME="onthetop-mig-prod"
      
          echo "be_version=$BE_VERSION" >> $GITHUB_OUTPUT
          echo "be_slot=$BE_SLOT" >> $GITHUB_OUTPUT
          echo "be_port=$BE_PORT" >> $GITHUB_OUTPUT
          echo "fe_version=$FE_VERSION" >> $GITHUB_OUTPUT
          echo "fe_slot=$FE_SLOT" >> $GITHUB_OUTPUT
          echo "region=$REGION" >> $GITHUB_OUTPUT
          echo "zone=$ZONE" >> $GITHUB_OUTPUT
          echo "mig_name=$MIG_NAME" >> $GITHUB_OUTPUT

      # ------------------ FE ÏóÖÎ°úÎìú ------------------

      - name: Download FE artifact from GitHub Release
        run: |
          curl -L -o fe.zip https://github.com/$GH_FE_REPO/releases/download/v${{ steps.vars.outputs.fe_version }}/frontend-prod-build.zip
          unzip -o fe.zip -d fe-dist

      - name: Upload FE to S3
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.S3_ACCESS_KEY }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.S3_SECRET_KEY }}
          AWS_DEFAULT_REGION: ap-northeast-2
        run: |
          aws s3 sync fe-dist/ s3://onthe-top/frontend/prod/${{ steps.vars.outputs.fe_slot }} --delete

      # ------------------ BE Î∞∞Ìè¨ ------------------

      - name: Find Instance URL from MIG
        id: get_ip
        run: |
          MIG="${{ steps.vars.outputs.mig_name }}"
          REGION="${{ steps.vars.outputs.region }}"
          ZONE="${{ env.ZONE }}"

          echo " Getting instance from MIG: $MIG in $REGION"

          INSTANCE_NAME=$(gcloud compute instance-groups managed list-instances "$MIG" \
            --region="$REGION" \
            --format="get(instance)" | sed -n 's|.*/||p')

          if [ -z "$INSTANCE_NAME" ]; then
            echo " MIG Ïù∏Ïä§ÌÑ¥Ïä§Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. MIG Ïù¥Î¶ÑÍ≥º REGIONÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî."
            exit 1
          fi

          echo " INSTANCE_NAME=$INSTANCE_NAME"

          IP=$(gcloud compute instances describe "$INSTANCE_NAME" --zone "$ZONE" \
            --format="get(networkInterfaces[0].networkIP)")

          echo " IP=$IP"

          echo "instance_name=$INSTANCE_NAME" >> $GITHUB_OUTPUT
          echo "instance_ip=$IP" >> $GITHUB_OUTPUT

      
      - name: Set up SSH config for Jump & Target
        run: |
          mkdir -p ~/.ssh

          echo "${{ secrets.JUMP_SSH_KEY }}" > ~/.ssh/jump_key
          chmod 600 ~/.ssh/jump_key

          echo "${{ secrets.SSH_KEY }}" > ~/.ssh/dev_key
          chmod 600 ~/.ssh/dev_key

          cat <<EOF > ~/.ssh/config
          Host backend-server
              HostName ${{ steps.get_ip.outputs.instance_ip }}
              User ubuntu
              IdentityFile ~/.ssh/dev_key
              ProxyJump jump-server
              StrictHostKeyChecking no
              UserKnownHostsFile /dev/null

          Host jump-server
              HostName ${{ secrets.JUMP_SSH_HOST }}
              User ubuntu
              IdentityFile ~/.ssh/jump_key
              StrictHostKeyChecking no
              UserKnownHostsFile /dev/null
          EOF

      - name: Generate secrets.properties file
        run: |
          mkdir -p ./secrets
          touch ./secrets/secrets.properties
          SECRET_LABELS="backend_shared backend_prod"

          for LABEL in $SECRET_LABELS; do
            gcloud secrets list --filter="labels.env=$LABEL" --format="value(name)" | while read SECRET_NAME; do
              SECRET_VALUE=$(gcloud secrets versions access latest --secret="$SECRET_NAME")
              IFS='-' read -r SERVICE KEY ENV <<< "$SECRET_NAME"
              echo "${KEY}=${SECRET_VALUE}" >> ./secrets/secrets.properties
            done
          done

      - name: Upload secrets.properties to server
        run: |
          ssh -F ~/.ssh/config backend-server 'mkdir -p ~/backend'
          scp -F ~/.ssh/config ./secrets/secrets.properties backend-server:/home/ubuntu/backend/secrets.properties
 

      - name: Deploy Dcoker Backend via SSH
        env:
          BE_VERSION: ${{ steps.vars.outputs.be_version }}
          BE_SLOT: ${{ steps.vars.outputs.be_slot }}
          BE_PORT: ${{ steps.vars.outputs.be_port }}
        run: |
          echo "‚ñ∂Ô∏è Deploying backend $BE_VERSION on slot $BE_SLOT (port $BE_PORT)..."
          ssh backend-server "BE_VERSION=${BE_VERSION} BE_SLOT=${BE_SLOT} BE_PORT=${BE_PORT} bash -s" <<'EOF'
              set -e

              # 0. ÌïÑÏàò Ìå®ÌÇ§ÏßÄ ÏÑ§Ïπò
              sudo apt update && sudo apt install -y docker.io jq gettext

              VERSION="$BE_VERSION"
              SLOT="$BE_SLOT"
              PORT="$BE_PORT"
              ENV="prod"
              CONTAINER_NAME="onthetop-backend-${SLOT}"

              # 2. Ïù¥Ï†Ñ Í∞ôÏùÄ slot Ïª®ÌÖåÏù¥ÎÑà ÏûàÎã§Î©¥ Ï†úÍ±∞
              echo "üßπ Cleaning up old container named $CONTAINER_NAME..."
              EXISTING_CONTAINER=$(docker ps -aq --filter "name=^/$CONTAINER_NAME\$" || true)
              if [ -n "$EXISTING_CONTAINER" ]; then
                docker rm -f "$EXISTING_CONTAINER"
              fi

              # 3. Docker Ïù¥ÎØ∏ÏßÄ pull
              echo " Pulling Docker image luckyprice1103/onthetop-backend:$VERSION"
              docker pull luckyprice1103/onthetop-backend:$VERSION

              # 4. Docker Ïù¥ÎØ∏ÏßÄ Ïã§Ìñâ
              echo " Running backend Docker container on port $PORT..."
              docker run -d \
                --name "$CONTAINER_NAME" \
                -p "$PORT":8080 \
                --memory=512m \
                --cpus=0.5 \
                -v /home/ubuntu/backend/secrets.properties:/app/secrets.properties \
                -v /var/log/onthetop/backend:/logs \
                -e SPRING_PROFILES_ACTIVE="$ENV" \
                luckyprice1103/onthetop-backend:$VERSION \
                --logging.file.name=/logs/backend.log \
                --spring.config.additional-location=file:/app/secrets.properties

              echo "‚úÖ Backend container is running on port $PORT"
          EOF

      - name: Health check
        env:
          BE_PORT: ${{ steps.vars.outputs.be_port }}
        run: |
          echo "ü©∫ Health check for backend container on port $BE_PORT..."

          ssh -F ~/.ssh/config backend-server <<EOF
            for i in {1..10}; do
              echo " [$i/10] Waiting for backend health on port $BE_PORT..."
              STATUS=\$(curl -s -o /dev/null -w "%{http_code}" http://localhost:$BE_PORT/api/v1/health || echo "000")
              if [ "\$STATUS" = "200" ]; then
                echo "‚úÖ Health check passed."
                exit 0
              fi
              sleep 10
            done

            echo "‚ùå Health check failed after 10 attempts."
            exit 1
          EOF


      - name: Switch Nginx to new backend slot
        env:
          BE_SLOT: ${{ steps.vars.outputs.be_slot }}
          BE_PORT: ${{ steps.vars.outputs.be_port }}
        run: |
          echo " Switching Nginx to $BE_SLOT (port $BE_PORT)..."

          ssh -F ~/.ssh/config backend-server BE_PORT=$BE_PORT bash -s <<EOF
            set -e
            NGINX_CONF="/etc/nginx/sites-enabled/backend"

            echo "server {
              listen 80;
              server_name _;
              location / {
                proxy_pass http://localhost:8080;
                proxy_set_header Host \"$""host\";
                proxy_set_header X-Real-IP \"$""remote_addr\";
                proxy_set_header X-Forwarded-For \"$""proxy_add_x_forwarded_for\";
              }
            }" | sudo tee \$NGINX_CONF > /dev/null

            echo "‚úÖ Nginx config updated to route to port \$BE_PORT"
            echo "üîÑ Reloading Nginx..."
            sudo nginx -t
            sudo systemctl reload nginx
          EOF
      # ------------------ CloudFront Origin Î≥ÄÍ≤Ω Î∞è Î¨¥Ìö®Ìôî ------------------

  cdn-update:
    needs: deploy
    runs-on: ubuntu-latest
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.CLOUDFRONT_ACCESS_KEY }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.CLOUDFRONT_SECRET_KEY }}
      AWS_DEFAULT_REGION: ap-northeast-2
      CLOUDFRONT_DISTRIBUTION_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
    steps:
      - name: Update CloudFront Origin
        run: |
          SLOT="${{ needs.deploy.outputs.fe_slot }}"
          DIST_ID="$CLOUDFRONT_DISTRIBUTION_ID"

          # ÏõêÎ≥∏ Ï†ÑÏ≤¥ Íµ¨ÏÑ± Î∞õÏïÑÏò§Í∏∞
          aws cloudfront get-distribution-config --id $DIST_ID > raw.json

          # ETag Ï∂îÏ∂ú
          ETAG=$(jq -r '.ETag' raw.json)

          # DistributionConfigÎßå Ï∂îÏ∂ú
          jq '.DistributionConfig' raw.json > config-only.json

          # OriginPath ÏàòÏ†ï
          jq --arg SLOT "$SLOT" \
            '.Origins.Items[0].OriginPath = "/frontend/prod/\($SLOT)"' \
            config-only.json > updated-config.json

          # ÏóÖÎç∞Ïù¥Ìä∏ Ï†ÅÏö©
          aws cloudfront update-distribution \
            --id $DIST_ID \
            --if-match $ETAG \
            --distribution-config file://updated-config.json

      - name: Invalidate CloudFront cache
        run: |
          SLOT="${{ needs.deploy.outputs.fe_slot }}"
          aws cloudfront create-invalidation \
            --distribution-id "$CLOUDFRONT_DISTRIBUTION_ID" \
            --paths "/" "/index.html" "/assets/*.js" "/assets/*.css"
